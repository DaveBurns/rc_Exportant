--[[
        Plugin configuration file (aka 'Advanced Settings').
        
        Note: Named members of return table are accessible in source code as:
        
            app:getPref( name )
            
            provided there is no app:initPref( name, val ) or app:setPref( name, val ) statements executed prior,
            which hide/override the named members in this file.
            
            
        *** Important: when editing, take care to assure punctuation and syntax are not disturbed. In comments, it doesn't matter, but in the rest - every character is meaningful,
                       including spaces, commas, brackets, dots, underscores...
                       
        There are 2 kinds of comments:
        1. single line
        2. multi-line (like this one).
        
        lines beginning with '--' (without the apostrophes) are single line comments.
        lines beginning with '- - [ [' (without the spaces) begin multi-line comments, which end with '- - ] ]' (without the spaces).
        
        Definitions:
        
        * Comment-out: to prepend '--' to a non-comment line making it a comment, or to wrap one or more non-comment lines with '- - [ [' & '- - ] ]'. This turns non-comment lines into comments, rendering them null & void for all practical purposes.
        * Un-comment: to remove the '--' at the front of a comment line thus enabling it to take effect (or removing '- - [ [' & '- - ] ]' wrappage).
        
        
        This configuration file is interpreted in the context of the Elare Plugin Framework - most Lr namespaces are available, and all standard Elare interface objects are available, including:
        
        String/text formatting:
        * str:fmtx - a derivative of Lightroom's LOC function - same syntax for specifying placeholders in the format string..., e.g.
            str:fmtx( "Hello ^1^2", "World", "!!!" ) -- will create the string: "Hello World!!!".
          string.format 'C' string formatting function, e.g.
            string.format( "%u times", count ) -- outputs "5 times", if count is 5.
        Debugging (ignored if advanced debugging is not enabled) :
        * Debug.lognpp - log any number of parameters in a "pretty" format, e.g.
            Debug.lognpp( "before", devSets, "after", photo:getDevelopSettings() ) -- log before and after develop settings.
        * Debug.pause and Debug.pauseIf - shows values of variables, if any, and presents options to keep going or stop, e.g.
            Debug.pause( myvar ) -- stop execution temporarily, and show the value of myvar variable.
            Debug.pause() -- show nothing, but confirm execution has reached this point.
        Logging to plugin log file:
        * app:log and app:logv log file methods, e.g.
            app:log( "Here it is: ^1", it ) -- log it
            app:logv( "hmm..." ) -- log hmm... - included in log file only if verbose logging is enabled.
            
        and MANY more, but the luadoc is out of date - see source code itself for reference.
          
        Reference documentation can be obtained by reading the API doc, downloadable as part of the Lightroom SDK, from here:
        
        http://www.adobe.com/devnet/photoshoplightroom.html
        
        Get lua language documentation from www.lua.org
--]]


-- declare return table
local _t = {}



-- Here are some plugins that have metadata you may be interested in:
-- local devMetaId = "com.robcole.lightroom.metadata.DevMeta" -- legacy.
local devMetaId = "com.robcole.lightroom.DevMeta" -- current.
local exifMetaId = "com.robcole.lightroom.ExifMeta"
local customMetadataId = "com.robcole.lightroom.CustomMetadata"
local changeManagerId = "com.robcole.lightroom.ChangeManager" -- explicit, for local use only.
-- consult the metadata module for each plugin to see which metadata IDs are available for folder/file naming.



--[[
        Date/time formatting.
        
        These are the options:
        •	%B: Full name of month
        •	%b: 3-letter name of month
        •	%m: 2-digit month number
        •	%d: Day number with leading zero
        •	%e: Day number without leading zero
        •	%j: Julian day of the year with leading zero
        •	%y: 2-digit year number
        •	%Y: 4-digit year number
        •	%H: Hour with leading zero (24-hour clock)
        •	%1H: Hour without leading zero (24-hour clock)
        •	%I: Hour with leading zero (12-hour clock)
        •	%1I: Hour without leading zero (12-hour clock)
        •	%M: Minute with leading zero
        •	%S: Second with leading zero
        •	%p: AM/PM designation
        •	%P: AM/PM designation, same as %p,but causes white space trimming to be applied as the last formatting step.
        •	%%: % symbol
        taken from SDK api doc, which is available here:
        
        http://www.adobe.com/devnet/photoshoplightroom.html
        
        Note: You can not use ‘:’ in Windows filenames, and so it’s not a good idea to put them in *any* filenames.
        
        Examples:
            Nick's preference:
                local defaultDateFormat = "%m-%d-%Y"
                local defaultTimeFormat = "%H_%M"
                local defaultDateTimeFormat = str:fmtx( "^1 ^2", defaultDateFormat, defaultTimeFormat )
            Rob's preference (the default):
                local defaultDateFormat = "%Y-%m-%d"
                local defaultTimeFormat = "%H-%M-%S"
                local defaultDateTimeFormat = str:fmtx( "^1_^2", defaultDateFormat, defaultTimeFormat )
--]]
local defaultDateFormat = "%Y-%m-%d"
local defaultTimeFormat = "%H-%M-%S"
local defaultDateTimeFormat = str:fmtx( "^1_^2", defaultDateFormat, defaultTimeFormat )



--[[
        Define replacement for missing metadata.
        
        Note: mdata should be nil or "" (blank string).
--]]
local function replaceMissingStuff( key, mdata )
    if mdata ~= nil then
        -- app:callingAssert( type( mdata ) == 'string', "missing not nil not string - hmm..." )
        -- app:callingAssert( #mdata == 0, "missing string not missing..." )
        return "blank" -- str:fmtx( "^1.blank", key ) - reminder: user can supply label - just need representative value.
    else
        return "nil" -- str:fmtx( "^1.nil", key ) - ditto
    end
end



--[[
        Define replacement for characters that don't do well in folder/filenames.
        
        nil key means do generic replacement
	
        Note: this should only be called when mdata is string, so check in calling context.
--]]
local function replaceFunnyStuff( key, mdata )
    app:callingAssert( mdata ~= nil, "mdata must not be nil" )
    if #mdata > 0 then
    	mdata = mdata:gsub( '/', '_[fs]_' )
    	mdata = mdata:gsub( '\\', '_[bs]_' )
    	mdata = mdata:gsub( ':', '[c]' )
    	mdata = mdata:gsub( '?', '[q]' )
    	mdata = mdata:gsub( '*', '[!]' )
    elseif key then
        mdata = replaceMissingStuff( key, "" )
    end
	return mdata
end



--[[
        Define replacement for unrecognized values corresponding to recognized keys.
        
        Note: value could be wrong because key is wrong, so...
        
        Note: key should not be blank, and mdata is usually not (but could be) nil. non-nil mdata could be any type.
--]]
local function replaceWrongStuff( key, mdata )
    app:callingAssert( str:is( key, "wrong-stuff key" ), "blank key" ) -- if key is not nil, but not string, str-is will through a data-type error using passed string.
    if mdata == nil then
        Debug.pause( key, "missing value is being considered wrong - why not missing?" ) -- generally wrong values are non-nil.
        return str:fmtx( "^1.nil", key ) -- key is output too in this case (see note in function header).
    else
        return str:fmtx( "^1.^2", key, mdata ) -- ditto.
    end
end



--[[
        Reformat Lr standard formatted metadata for compatibility with folder/filenames.
        
        Goal is for metadata to match "as you see in Lightroom" as much as possible.
--]]
local function reformatFormattedMetadata( params )
    local photo = params.photo or error( "no photo" )
    local key = params.key or error( "no key" )
    local mdata = params.metadata -- may be blank nil, or less likely 'false'.
    local rawMeta = params.rawMeta or error( "no raw meta" )
    local fmtMeta = params.fmtMeta or error( "no fmt meta" )
    local typ = type( mdata )
    if not str:is( key ) then
        return ""
    end
    if typ == 'string' then
        return replaceFunnyStuff( key, mdata )
    elseif typ == 'nil' then
        if key == 'rating' then
            return "" -- unrated.
        else
            return replaceMissingStuff( key ) -- nil
        end
    elseif typ == 'boolean' then
        return tostring( mdata ) -- 'true' or 'false'.
    elseif typ == 'number' then -- e.g. rating.
        if key == 'rating' then
            if mdata == 0 then
                return ""
            else
                return string.rep( "*", mdata )
            end
        else
            return tostring( mdata )
        end
    -- reminder: @12/Nov/2013 21:21, this never happens, since formatted metadata is "simple" (so table values are not present), but that could change..
    elseif typ == 'table' then -- note: by default, tables are returned in raw metadata, not formatted.
--[[    Note: all tables in formatted metadata are listed here:
        ======================================================
        IPTC Extension:
        ---------------
        locationCreated
        locationShown
        artworksShown
        registryId
        ---------------
        PLUS:
        -----
        imageSupplier
        imageCreator
        copyrightOwner
        licensor
        ----
--]]    
        app:show{ warning="IPTC Extension and PLUS (table) metadata not yet supported: ^1.", key }
        return ""
    else -- probably never happens:
        app:show{ warning="^1 metadata not supported, key: ^2, value: ^3.", typ, key, mdata }
        return ""
    end
end



--[[
        Format Lr standard raw metadata for compatibility with folder/filenames.
--]]
local function formatRawMetadata( params, dateTimeFormat )
    if str:is( dateTimeFormat ) then
        dateTimeFormat = replaceFunnyStuff( nil, dateTimeFormat )
    end
    local photo = params.photo or error( "no photo" )
    local key = params.key or error( "no key" )
    local rawMeta = params.rawMeta or error( "no raw meta" )
    local fmtMeta = params.fmtMeta or error( "no fmt meta" )
    local mdata = params.metadata
    local typ = type( mdata )
    if not str:is( key ) then
        return ""
    end
    if typ == 'number' then -- e.g. raw (numeric) date/times, rating, and pick-status.
        if key == 'rating' then
            if mdata == 0 then
                Debug.pause( "rating is zero" )
                return "0" -- I don't think this ever happens, since unrated is actually nil, not zero.
            else
                return tostring( mdata )
            end
        elseif key == 'pickStatus' then
            if mdata == 0 then
                return "unpicked"
            elseif mdata == 1 then
                return "picked"
            elseif mdata == -1 then
                return "rejected"
            else
                return str:fmtx( "^1.^2", key, mdata )
            end
        elseif key == 'aspectRatio' then
            if mdata then
                return string.format( "%.1f", mdata )
            else
                return replaceMissingStuff( key ) -- nil
            end
        elseif key:sub( 1, 4 ) == 'date' then
            return LrDate.timeToUserFormat( mdata, dateTimeFormat or defaultDateTimeFormat )
        elseif key:find( "Time" ) then
            return LrDate.timeToUserFormat( mdata, dateTimeFormat or defaultDateTimeFormat )
        else -- e.g. video duration when photo
            Debug.pause( key, mdata )
            return tostring( mdata )
        end
    elseif typ == 'string' then
        return reformatFormattedMetadata( params ) -- sorta cheating, just be aware: raw strings are considered formatted metadata.
    elseif typ == 'nil' then -- raw metadata is absent
        if key == 'rating' then
            return "0" -- unrated
        elseif key:sub( 1, 4 ) == 'date' then
            local file = rawMeta['path']
            if fso:existsAsFile( file ) then
                local attrs = LrFileUtils.fileAttributes( file )
                if attrs then
                    local dt = attrs.fileCreationDate
                    if dt then
                        return LrDate.timeToUserFormat( dt, dateTimeFormat or defaultDateTimeFormat )
                    else
                        return replaceWrongStuff( key ) -- nil
                    end
                else
                    error( "no attrs" )                    
                end
            else
                Debug.pause( key, "file is missing" ) -- ideally, missing files would be detected prior to now, but this could be smart preview exporting.
                return str:fmtx( "[NO ^1]", key ) -- file missing is a little different than metadata missing.
            end
        else
            Debug.pause( key, "missing raw data" )
            return replaceMissingStuff( key )
        end
    elseif typ == 'boolean' then
        return tostring( mdata )
    elseif typ == 'table' then -- note: by default, tables are returned in raw metadata, not formatted.
        if key == 'dimensions' or key == 'croppedDimensions' then
            return str:fmtx( "^1x^2", mdata.width, mdata.height )
        elseif key == 'gps' then
            local lat = mdata.latitude
            local lon = mdata.longitude
            if lat and lon then -- numeric
                return str:fmtx( "(^1, ^2)", string.format( "%.5f", lat ), string.format( "%.5f", lon ) )
            else
                Debug.pause( key, "no lat/long" )
                return replaceMissingStuff( key ) -- nil (this should never happen)
            end
        elseif key == 'durationRatio' or key == 'trimmedDurationRatio' then
            local n = mdata.numerator
            local d = mdata.denominator
            if n and d then -- numeric
                return str:fmtx( "(^1, ^2)", n, d )
            else
                Debug.pause( key, "no num/den" )
                return replaceMissingStuff( key ) -- nil (shouldn't happen).
            end
        elseif key == 'smartPreviewInfo' then
            if tab:isNotEmpty( mdata ) then -- has smart preview
                return "present"
            else
                return "absent"
            end
        elseif key == 'customMetadata' then
            app:show{ warning="Custom (plugin) metadata not available via raw metadata - should be implemented as true 'Custom Metadata'." }
            return ""
        else
            app:show{ warning="Raw metadata table not supported yet, key: ^1", key }
            return ""
        end
    else
        app:show{ warning="^1 raw metadata not supported, key: ^2, value: ^3", typ, key, mdata }
        return ""
    end
end



--[[
        Get and format custom metadata.
        
        Note: keys comes from values in getCustomMetadataItems function below. 
        
        *** this function can not yield.
--]]
local function getCustomMetadata( params )
    --app:callingAssert( LrTasks.canYield(), "no can yield" )
    local photo = params.photo or error( "no photo" )
    local settings = params.settings or error( "no settings" )
    local key = params.key or error( "no key" )
    local fmtMeta = params.fmtMeta or error( "no fmt meta" )
    local rawMeta = params.rawMeta or error( "no raw meta" )
    if not str:is( key ) then
        return ""
    elseif key == 'fileNameBase' then
        return LrPathUtils.removeExtension( fmtMeta.fileName )
    elseif key == 'dateOriginal' then
        params.key = 'dateTimeOriginal'
        params.metadata = rawMeta[params.key]
        return formatRawMetadata( params, defaultDateFormat )
    elseif key == 'timeOriginal' then
        params.key = 'dateTimeOriginal'
        params.metadata = rawMeta[params.key]
        return formatRawMetadata( params, defaultTimeFormat )
    elseif str:isBeginningWith( key, 'dto_' ) then
        local fmt = key:sub( 5 )
        if str:is( fmt ) then
            params.key = 'dateTimeOriginal'
            params.metadata = rawMeta[params.key]
            return formatRawMetadata( params, fmt )
        else
            app:show{ warning="'dto_' must be followed by valid data/time format string, e.g. with %'s in it." }
        end
    elseif str:isBeginningWith( key, 'dt_' ) then
        local fmt = key:sub( 4 )
        if str:is( fmt ) then
            params.key = 'dateTime'
            params.metadata = rawMeta[params.key]
            return formatRawMetadata( params, fmt )
        else
            app:show{ warning="'dt_' must be followed by valid data/time format string, e.g. with %'s in it." }
        end
    elseif str:isBeginningWith( key, 'dtd_' ) then
        local fmt = key:sub( 5 )
        if str:is( fmt ) then
            params.key = 'dateTimeDigitized'
            params.metadata = rawMeta[params.key]
            return formatRawMetadata( params, fmt )
        else
            app:show{ warning="'dt_' must be followed by valid data/time format string, e.g. with %'s in it." }
        end
    elseif str:isBeginningWith( key, 'dtfc_' ) then
        local fmt = key:sub( 6 )
        if str:is( fmt ) then
            params.key = 'date' -- generic "date" trick.
            params.metadata = nil -- forces file-creation-time to be returned.
            return formatRawMetadata( params, fmt )
        else
            app:show{ warning="'dtfc_' must be followed by valid data/time format string, e.g. with %'s in it." }
        end
    elseif str:isBeginningWith( key, 'dtfm_' ) then
        local fmt = key:sub( 6 )
        if str:is( fmt ) then
            params.key = 'dateMod' -- when metadata nil, this is last-mod time.
            params.metadata = nil  -- metadata nil means "requires special handling" to acquire date metadata.
            return formatRawMetadata( params, fmt )
        else
            app:show{ warning="'dtfm_' must be followed by valid data/time format string, e.g. with %'s in it." }
        end
    elseif str:isBeginningWith( key, 'dtc_' ) then -- date-time current.
        local fmt = key:sub( 5 )
        if str:is( fmt ) then
            params.key = 'dateNow' -- when metadata nil, this is current time.
            params.metadata = nil  -- metadata nil means "requires special handling" to acquire date metadata.
            return formatRawMetadata( params, fmt )
        else
            app:show{ warning="'dtc_' must be followed by valid data/time format string, e.g. with %'s in it." }
        end
    elseif key == 'parentFolderName' then
        local dir = LrPathUtils.parent( rawMeta.path )
        return LrPathUtils.leafName( dir )
    elseif key == 'grandParentFolderName' then
        local dir = LrPathUtils.parent( rawMeta.path )
        if str:is( dir ) then
            dir = LrPathUtils.parent( dir )
            if str:is( dir ) then
                return LrPathUtils.leafName( dir )
            end
        end
        return "root"        
    elseif key == 'greatGrandParentFolderName' then
        local dir = LrPathUtils.parent( rawMeta.path )
        if str:is( dir ) then
            dir = LrPathUtils.parent( dir )
            if str:is( dir ) then
                dir = LrPathUtils.parent( dir )
                if str:is( dir ) then
                    return LrPathUtils.leafName( dir )
                end
            end
        end
        return "root"
    elseif key == 'catalogName' then
        local dir, name = cat:getCatDir()
        return name
    elseif key == 'exifMeta_lastUpdate' then
        local emDat = rawMeta.customMetadata[str:fmtx( '^1.lastUpdate', exifMetaId)] -- always present if exif-meta installed & enabled.
        if str:is( emDat ) then
            return emDat
        else
            app:error( "ExifMeta plugin is not installed or not enabled, or something. Another option for exif metadata in names - use exif-tool session instead of ExifMeta plugin." )
        end
        --Debug.lognpp( rawMeta.customMetadata )
        --Debug.showLogFile()
    elseif key:find( 'oll_' ) then -- collection (name).
        local collInfo
        if key:find( 'egColl_' ) then
            collInfo = params.regCollInfo -- collection is key, value is table with rootName and collName members.
        elseif key:find( 'ubColl_' ) then
            collInfo = params.pubCollInfo -- ditto.
        else
            app:error( "bad token key: '^1'", key )
        end
        local uScore = key:find( "_" )
        local collRootSet = key:sub( uScore + 1 )
        local baseKey = key:sub( 1, uScore - 1 )
        if not str:is( collRootSet ) then
            collRootSet = "[root]"
        end
        local name
        local set = {}
        if tab:is( collInfo ) then
            for coll, names in pairs( collInfo ) do
                local rootName
                if #names > 1 then
                    rootName = names[#names]
                else
                    rootName = "[root]"
                end
                if str:is( rootName ) then
                    if str:isBeginningWith( rootName, collRootSet ) then -- defaults to plain text.
                        if baseKey == 'regColl' then
                            name = names[1]
                            break
                        elseif baseKey == 'pRegColl' then
                            name = names[2] or "parent"
                            break
                        elseif baseKey == 'gpRegColl' then
                            name = names[3] or "gparent"
                            break
                        elseif baseKey == 'pubColl' then
                            name = names[1]
                            break
                        elseif baseKey == 'pPubColl' then
                            name = names[2] or "parent"
                            break
                        elseif baseKey == 'gpPubColl' then
                            name = names[3] or "gparent"
                            break
                        else
                            app:error( "bad base key: ^1", baseKey )
                        end
                    else
                        set[rootName] = true
                    end
                else
                    set["?"] = true
                end
            end
        else
            return replaceMissingStuff( key )
        end
        if str:is( name ) then
            return replaceFunnyStuff( baseKey, name )
        elseif tab:is( set ) then
            local array = tab:createArrayFromSet( set )
            table.sort( array )
            return table.concat( array, "; " )
        else
            return replaceMissingStuff( key ) 
        end
    else
        app:error( "'^1' token is not defined", key )
    end
    return key
end



--[[
        Define UI (title) and values (ID passed to getCustomMetadata function as 'key') for custom metadata.
        
        Note: elements are stripped of path separators, so there can be no "source sub-path" item for example.
        (use tree-sync-publisher if such folder structure is desired, or implement via get-custom-dir function.
        
        Note2: You can put whatever you want for both title and value - just make sure they are unique.
               The values must be detected in getCustomMetadata function above (key).
--]]
_t.getCustomMetadataItems = function()
    return {
        { title="Filename (without extension)", value="fileNameBase" },
        { title="Parent Folder", value="parentFolderName" },
        { title="Grandparent Folder", value="grandParentFolderName" },
        { title="Great Grandparent Folder", value="greatGrandParentFolderName" },
        { title="Collection", value='regColl_[REPLACE-THIS-BRACKETED-EXPRESSION-WITH-BEGINNING-OF-ROOT-COLLECTION-SET-NAME]' },
        { title="Parent Collection", value='pRegColl_[REPLACE-THIS-BRACKETED-EXPRESSION-WITH-BEGINNING-OF-ROOT-COLLECTION-SET-NAME]' },
        { title="Grandparent Collection", value='gpRegColl_[REPLACE-THIS-BRACKETED-EXPRESSION-WITH-BEGINNING-OF-ROOT-COLLECTION-SET-NAME]' },
        { title="Publish Collection", value='pubColl_[REPLACE-THIS-BRACKETED-EXPRESSION-WITH-BEGINNING-OF-ROOT-COLLECTION-SET-NAME]' },
        { title="Parent Publish Collection", value='pPubColl_[REPLACE-THIS-BRACKETED-EXPRESSION-WITH-BEGINNING-OF-ROOT-COLLECTION-SET-NAME]' },
        { title="Grandparent Publish Collection", value='gpPubColl_[REPLACE-THIS-BRACKETED-EXPRESSION-WITH-BEGINNING-OF-ROOT-COLLECTION-SET-NAME]' },
        { title="Catalog", value="catalogName" },
        
        { separator = true },
        { title="Date Original (capture date)", value="dateOriginal" },
        { title="Time Original (capture time)", value="timeOriginal" },

        -- free format date/times
        { separator = true },
        { title="Date/Time Original (free format)", value="dto_%Y-%m-%d_%H-%M-%S" },
        { title="Date/Time Digitized (free format)", value="dtd_%Y-%m-%d_%H-%M-%S" },
        { title="Date/Time File Created (free format)", value="dtfc_%Y-%m-%d_%H-%M-%S" },
        { title="Date/Time \"Generic\" (free format)", value="dt_%Y-%m-%d_%H-%M-%S" },
        
        { separator = true },
        { title="Exif Meta - Last Update", value="exifMeta_lastUpdate" },
        
        -- convenience entry to aid re-selecting same item (leave this alone):
        { separator = true },
        { title="None", value="" }, -- "nothing" selected.
    }
end



--[[
        Replace tokens with the text they represent.
        
        PS - Called from async task.
--]]
local function replaceTokens( photo, props, propKey )

    --app:callingAssert( LrTasks.canYield(), "replace tokens must be able to yield" )
    -- note: gsub func can not yield.

    assert( reformatFormattedMetadata, "no fmtr" )
    assert( formatRawMetadata, "no rfmtr" )
    assert( getCustomMetadata, "no cmfmtr" )
    
    local fmtMeta = photo:getFormattedMetadata()
    local rawMeta = photo:getRawMetadata()
    local collInfo
    local parents
    local function considerParent( parent, coll )
        if parent ~= nil then
            parents[#parents + 1] = parent:getName()
            considerParent( parent:getParent(), coll )
        else
            collInfo[coll] = parents
        end
    end
    local function doColls( colls )
        collInfo = {}
        for i, v in ipairs( colls ) do
            parents = { v:getName() }
            considerParent( v:getParent(), v )
        end
    end

    local function xlate( val )
        local regCollInfo
        local pubCollInfo
        if val:find( "egColl_" ) then
            doColls( photo:getContainedCollections() ) -- this may be the empty set (excludes smart collections).
            regCollInfo = collInfo
        end
        if val:find( "ubColl_" ) then
            local pc = photo:getContainedPublishedCollections() -- reminder: this may be the empty set (excludes smart publish collections).
            doColls( pc ) -- returns quick if no pub-colls.
            pubCollInfo = collInfo
        end
    	local function fmtFunc( token )
    	    local key = token:sub( 4, -2 )
    		local metadata = reformatFormattedMetadata {
    		    photo = photo,
    		    settings = props,
    		    key = key,
    		    metadata = fmtMeta[key],
    		    fmtMeta=fmtMeta,
    		    rawMeta=rawMeta,
    		}
    		return metadata or ""
    	end
    	local function rawFunc( token )
    	    local key = token:sub( 4, -2 )
    		local metadata = formatRawMetadata {
    		    photo = photo,
    		    settings = props,
    		    key = key,
    		    metadata = rawMeta[key],
    		    fmtMeta=fmtMeta,
    		    rawMeta=rawMeta,
    		}
    		return metadata or ""
    	end
    	local function custFunc( token )
    	    local key = token:sub( 4, -2 )
    		local metadata = getCustomMetadata {
    		    photo=photo,
    		    settings=props,
    		    key=key, -- more of an ID.
    		    fmtMeta=fmtMeta,
    		    rawMeta=rawMeta,
    		    regCollInfo=regCollInfo,
    		    pubCollInfo=pubCollInfo,
    		}
    		return metadata or ""
    	end
    	local rslt = val:gsub('($F%b{})', fmtFunc )
    	rslt = rslt:gsub('($R%b{})', rawFunc )
    	if getCustomMetadata then
    	    rslt = rslt:gsub('($C%b{})', custFunc )
    	end
    	return rslt
    end
    
    local rslt = xlate( LrStringUtils.trimWhitespace( props[propKey] ) )
    return replaceFunnyStuff( nil, rslt )
end



--[[
        Called to get sub-path to be used for custom folder naming.
        
        Final export location is governed by get-custom-dir function, but this is used (externally) for UI sample display,
        and may be used internally (in here) too.
--]]
_t.getSubPath = function( photo, props, propKey )
    return replaceTokens( photo, props, propKey )
end



--[[
        Called to get base of filename to be used for custom file naming.
        
        Final filename is governed by get-custom-text-replacement function (extension is handled externally),
        but this is used (externally) for UI sample display, and may be used internally (in here) too.
--]]
_t.getFileBaseName = function( photo, props, propKey )
    return replaceTokens( photo, props, propKey )
end



--[[
        called during export "pre-processing", if corresponding box checked in UI.
        
        reminder: app--display-error will flash only briefly if no photos are ok-to-export, and reload-upon-export is enabled.
        
        return status (boolean, required) true if ok, or probably ok; false if not ok, or probably not.
        return message (string, optional) if returned, photo will be included in prompt - whether checkbox ticked (enabled for export) or not depends on status.
        
        Examples:
            return true -- ok to export, no do not include in prompt.
            return false -- not ok to export, do not include in prompt.
            return true, "Everything OK" -- include in prompt, checked by default.
            return false, "Something is Off" -- include in prompt, unchecked by default.
--]]
_t.okToExport = function( params )
    app:callingAssert( params, "no params" )
    -- export settings and photo are all that is available in params.
    local photo = params.photo or error( "no photo" )
    local photoName = cat:getPhotoNameDisp( photo, true ) -- full name, no cache.
    app:logv()
    app:logv( "Considering whether ok to export '^1'", photoName )
    local settings = params.exportSettings or error( "no export settings" )
    -- note: this function is called before filter-context created - list of photos not yet available, so no metadata cache...
    -- note: is-finished is implemented as a shared property so it can be called in more than one context (by any plugin).
    local errb = {}
    local isFinishedFunc, errm = fprops:getSharedProperty{ name='isFinished' } -- , expectedType='function' - going to be called frequently, so not type checking.
    if isFinishedFunc then
        local ok, err = isFinishedFunc{ whosAsking=app:getInfo( 'LrToolkitIdentifier' ), photo=photo, cache=nil } -- does a fair amount of verbose logging.
        if ok then
            app:logV( "photo editing is finished" )
        else
            errb[#errb + 1] = str:fmtx( "photo editing is not finished - ^1", err )
        end
    else
        --Debug.pause( "No 'isFinished' func as shared property." )
        errb[#errb + 1] = str:fmtx( "no 'isFinished' func as shared property - ^1", errm )
    end
    local locked, lockDate = cat:isLocked( photo )
    if locked then
        app:logv( "locked on ^1", lockDate )
    else
        errb[#errb + 1] = "not locked"
    end
    local doExport
    local msg -- not necessarily an error message, although may be.
    if #errb == 0 then -- no error messages in buffer.
        doExport = true -- no errm => exclude display of photos that passed with flying colors.
        -- msg = photoName -- uncomment this line and maybe come up with a better msg if you want to also double-check acceptable photos prior to export.
    else -- see if do-export, or not..
        msg = table.concat( errb, " | " )
        doExport = false -- only affects initial checkmark.
    end
    
    return doExport, msg
end



--[[
        Determines export directory given source photo, settings, ...
--]]
_t.getCustomDir = function( params )
    local photo = params.photo or error( "no photo" )
    local rendition = params.rendition -- not an error - may be called for sampling too...
    local settings = params.settings
    local exifToolSession = params.exifToolSession
    local dir = params.dir or error( "no dir" )
    local newDir = dir
    local filename = params.filename or error( "no filename" )
    local filePath = params.filePath or error( "no file-path" )
    local cache = params.cache or error( "no cache" ) -- metadata
    --Debug.lognpp( settings, dir, filename )
    local exifMetadata
    if exifToolSession then
        local ver, more = exifToolSession:getVersionString()
        if str:is( ver ) then
            app:logv( "Exiftool version: ^1", ver )
        elseif str:is( more ) then
            app:logv( more )
        else
            app:logWarning( "Unable to obtain exiftool version in session mode - make sure 'Reload each export' is *NOT* checked." )
        end
        exifToolSession:addArg( "-S" ) -- get exif metadata in 'S' format.
        exifToolSession:addTarget( filePath )
        local rslt, errm = exifToolSession:execute()
        if not str:is( errm ) then -- no error message
            if str:is( rslt ) then
                app:logv( "Exiftool session OK" )
                -- exifMetadata = exifTool:parseShorty( rslt ) -- uncomment this line to have exif metadata available for naming.
            else
                app:log( "No exif metadata" )
            end
        else
            app:logWarning( "Unable to obtain exif metadata - ^1", errm )
        end
    else
        app:logv( "No exiftool session." )
    end
    if str:is( settings.folderSubPath ) then
        fso:assureDir( dir )
        local subpath = _t.getSubPath( photo, settings, 'folderSubPath' )
        newDir = LrPathUtils.standardizePath( LrPathUtils.child( dir, subpath ) ) -- std-pth and an export-subfolder will interpret .. as parental dir, on Windows (Andreas Muller said he was doing it before the std-pth wrapper, but I don't see how, maybe on Mac..
        --Debug.pause( newDir )
        fso:assureDir(  newDir )
    else
        app:logv( "no folder sub-path" ) -- no longer an error - since custom folder naming is now enabled by default.
    end
    return newDir
end



--[[
        *** Instructions:
        
        Edit this function to return a string to replace '_Exportant_' which should be typed into custom-text field in file naming template that includes custom text.
        
        Note: by default, " (copy-name)" will be appended to base filename if source photo is virtual copy, and nothing will be appended if master real copy (i.e. not a virtual copy).
--]]
_t.getCustomTextReplacement = function( params )
    local photo = params.photo or error( "no photo" )
    local rendition = params.rendition -- not an error (could be used to determine whether being called for true rendition, or sample - although might not matter).
    local settings = params.settings 
    local exifToolSession = params.exifToolSession
    local dir = params.dir
    local filename = params.filename
    local filePath = params.filePath or error( "no file-path" )
    --Debug.lognpp( settings, dir, filename )
    local exifMetadata
    if exifToolSession then
        local ver, more = exifToolSession:getVersionString()
        if str:is( ver ) then
            app:logV( "Exiftool version: ^1", ver )
        elseif str:is( more ) then
            app:logV( more )
        else
            app:logW( "Unable to obtain exiftool version in session mode - make sure 'Reload each export' is *NOT* checked." )
        end
        exifToolSession:addArg( "-S" ) -- get exif metadata in 'S' format.
        exifToolSession:addTarget( filePath )
        local rslt, errm = exifToolSession:execute()
        if not str:is( errm ) then -- no error message
            if str:is( rslt ) then
                app:logv( "Exiftool session OK" )
                --exifMetadata = exifTool:parseShorty( rslt ) -- uncomment this line to have exif metadata available for naming.
            else
                app:log( "No exif metadata" )
            end
        else
            app:logWarning( "Unable to obtain exif metadata - ^1", errm )
        end
    else
        app:logV( "No exiftool session." )
    end
    -- default (replacement) filename: {token-replaced-base}[ ({copy-name})].{ext}
    local baseFilename = _t.getFileBaseName( photo, settings, 'fileBaseName' )
    if str:is( baseFilename ) then
        -- got something from field
        local virt = photo:getRawMetadata( 'isVirtualCopy' )
        if virt then
            return str:fmtx( "^1 (^2)", baseFilename, photo:getFormattedMetadata( 'copyName' ) )
        else -- do not include 
            return baseFilename
        end
    else
        return "" -- return blank means use non-customized value.
    end
end



--[[
        Called upon for each exporting photo or video (*before* export has taken place) if 'Custom Export Function' is enabled.
        
        Must return true to indicate success.
        Must return false, "and some sort of error message" to indicate failure.
        
        For example:
            return true -- worked.
            return false, "I don't know why" -- failed.
--]]
_t.customExportFunc = nil -- no custom export function defined - delete this line and uncomment below (*and* edit to do what you want), to enable custom export function.
--[[
_t.customExportFunc = function( params )
    app:callingAssert( params, "no params" )
    -- export settings and photo are all that is available in params.
    local photo = params.photo or error( "no photo" )
    local newPath = params.newPath or error( "no new path" )
    local photoName = cat:getPhotoNameDisp( photo, true ) -- true => full path in name; no metadata cache.
    app:logv( "Performing custom export function - target photo: '^1'", photoName )
    local exportSettings = params.exportSettings or error( "no export settings" ) -- export settings as set by user in export dialog box.
    
    --local settings = tab:copy( exportSettings ) -- make copy, since it makes me nervous changing base set, even though I think it doesn't matter at this point.
    local settings = {} -- define settings from scratch.
    
    local parent = LrPathUtils.parent( newPath )
    local dir = LrPathUtils.child( parent, "high_res" )
    local s, m = fso:assureDir( dir )
    if not s then
        error( m )
    end
    local fn = LrPathUtils.leafName( newPath )
    
    -- uncomment these lines and enable advanced debug in plugin manager to get a dump of the export settings in the debug log file.
    -- note: change settings and re-run the export to see how various options are coded.
    --Debug.lognpp( exportSettings )
    --Debug.showLogFile()
    
    -- set/override export settings here:
    settings.LR_jpeg_quality = 1 
    settings.LR_collisionHandling = "overwrite"
    settings.LR_export_useSubfolder = false
    settings.LR_format = "JPEG"
    settings.LR_ui_enableWatermark = true
    settings.LR_removeLocationMetadata = true
    settings.LR_size_doConstrain = true         -- do resize
    settings.LR_size_resizeType = 'wh'          -- width x height
    settings.LR_size_maxWidth = 240             -- square cell
    settings.LR_size_maxHeight = 240            --    "
    settings.LR_size_doNotEnlarge = true        -- hopefully a "don't care".
    settings.LR_extensionCase = "lowercase"
    settings.LR_reimportExportedPhoto = false
    settings.LR_export_colorSpace = "sRGB"
	settings.LR_tokens = "{{image_name}}" -- filename.
    settings.LR_export_destinationType = "specificFolder"
    settings.LR_export_destinationPathPrefix = dir -- folder
    settings.LR_export_destinationPathSuffix = "" -- no subfolder
    
    local session = LrExportSession {
        photosToExport = { photo },
        exportSettings = settings,
    }
    
    -- *** uncomment these lines to enable custom export functionality:
    -- local s, m = LrTasks.pcall( session.doExportOnCurrentTask, session ) -- perform export synchronously (without spawning another asynchronous task).
    -- return s, m
    
    -- delete these lines after uncommenting the above lines:
    return false, "user needs to edit advanced settings, custom export function, and uncomment lines according to instructions..."
end
--]]



--[[
        Called upon after each photo or video has been exported, if 'Custom Post-export Func' is enabled.

        Nothing returned - rendition and logging must be handled within.
--]]
_t.customPostExportFunc = nil -- no custom export function defined - delete this line and uncomment below (*and* edit to do what you want), to enable custom post-export function.
--[[
_t.customPostExportFunc = function( params )
    local sourceRendition = params.sourceRendition or error( "no src rend" )
    local renditionToSatisfy = params.renditionToSatisfy or error( "no rend to sat" )
    local exportedFilePath = params.exportedFilePath or error( "no video path" )
    local exportSettings = params.exportSettings or error( "no settings" )
    local photo = params.photo or error( "no photo (video)" ) -- LrPhoto object is a video.
    local call = params.call or error( "no call" )
    -- local cache = call.cache, - cache only present if init-function option specified - get from call object directly if you know it's there.
    local functionContext = params.functionContext or error( "no funct ctxt" )
    local filterContext = params.filterContext or error( "no filt ctxt" )
    local exportFilter = params.exportFilter or error( "no filter" )
    -- renditionToSatisfy:renditionIsDone( true ) - ya can't set it to true if it ain't so..
    renditionToSatisfy:renditionIsDone( false, "customizing agent (person) hasn't set 'renditionToSatisfy:renditionIsDone' to true..." )
end
--]]



--[[
        called as export process is taking off: good place to add (raw and/or formatted) metadata of photos to be exported, to cache.
        reminder: called *after* ok-to-export.
        I think rendering has already begun, so it may be too late to deny rendition.
        Note: @v5, this function serves custom (export) functions only (not custom naming...).
        
        Examples:
            _t.initExport = nil -- no need for pre-export run initialization.
            _t.initExport = function( params )
                app:callingAssert( params, "no params" )
                local exportFilter = params.exportFilter or error( "no export filter" )
                local exportSettings = params.exportSettings or error( "no export settings" )
                local photos = params.photos or error( "no photos" )
                local cache = params.cache or error( "no metadata cache" )
                -- cache:addRawMetadata( photos, { "keywords" } )
                -- cache:addFormattedMetadata( photos, { "copyName" } )
                local errorMessage -- In case of error, set message string.
                if not errorMessage then
                    return true -- proceed with export.
                else
                    return false, errorMessage
                end
            end
--]]
_t.initExport = nil



--[[
        ChangeManager toolkit ID, used for determining photo lock status from other (non-ChangeManager) plugins,
        and/or for pausing ChangeManager's background task from other plugins.
        
        Leave this nil if you don't use ChangeManager (or at least not for the locking feature),
        or if you want leave it up to the plugin to determine whether ChangeManager is installed and what it's ID is.
        
        Or, you can set an explicit value if you are using a bastardized version of it, or have more than one version installed.
        
        Examples:
        
            _t.changeManagerId = nil -- ChangeManager not used, or let plugin figure it.
            _t.changeManagerId = "com.robcole.debug.ChangeManagerDebug" -- running special debug version of ChangeManager.
--]]
_t.changeManagerId = nil -- changeManagerId -- assign local ID as plugin-wide pref.



--[[
        Develop preset folder filter - only presets in folders containing specified substring (case sensitive) will be presented.
        
        Examples:
            _t.devPresetFolderSubstring = 'Export' -- present only presets in folders containing the substring "Export".
            _t.devPresetFolderSubstring = 'Relative' -- present only presets in folders containing the substring "Relative".
            _t.devPresetFolderSubstring = nil -- present all develop presets.
--]]
_t.devPresetFolderSubstring = nil



--[[
        Metadata preset filter - only presets containing specified substring (case sensitive) will be presented.
        
        Examples:
            _t.metaPresetFolderSubstring = 'Export' -- present only presets whose name contains the substring "Export".
            _t.metaPresetFolderSubstring = nil -- present all metaelop presets.
--]]
_t.metaPresetSubstring = nil



--[[
        Force Exportant to save xmp the old way, even in Lr5+.
        
        Note: this setting has no bearing unless 'Save XMP upon export' is enabled in export dialog box.
        
        Why? - the new (Lr5+) way is prone to various anomalies.
        
        Examples:
            _t.saveXmpTheOldWay = true -- @20/Oct/2013 17:44, more reliable if it works.
            _t.saveXmpTheOldWay = false -- new way must be used, since host system not supporting keyboard stuffing script (the old way) - requires Lr5+.
            _t.saveXmpTheOldWay = nil -- Let plugin decide whether to use the old way or the new way (@20/Oct/2013 17:41, it will try to use the new way, if supported, so try setting this to true if not working reliably).
--]]
_t.saveXmpTheOldWay = nil



--[[
        Smart preview size (long edge).

        Examples:
            _t.smartPreviewSize = 2560 -- default @Lr5.2
            _t.smartPreviewSize = 2540 -- default @Lr5.0
            _t.smartPreviewSize = 1680 -- resized via PreviewExporter.
            _t.smartPreviewSize = 4282 -- test to see what percentages would be if smart preview size same as original D300 raws.
            _t.smartPreviewSize = nil -- Let plugin compute smart preview size (@27/Oct/2013, it will choose 2560, since one would have to be insane to still be using 5.0).
            
        Note: Actual smart preview size will be same as original, if original is smaller than smart preview (max) size.
--]]
_t.smartPreviewSize = nil



--[[
        Thumbnail view size (size of square bounding box).

        Examples:
            _t.thumbSize = 64 -- medium: the default.
            _t.thumbSize = 32 -- tiny - I prefer more items.
            _t.thumbSize = 128 -- large - I prefer larger thumbs.
            _t.thunbSize = 0 -- omit thumbs - I don't need them.
            _t.thumbSize = nil -- let plugin decide (@27/Oct/2013, it will choose medium).
--]]
_t.thumbSize = nil



--[[
        Use smart preview collections?
        
        Examples:
            _t.useCollections = true -- Yes: put exported or skipped photos into plugin collections, and prompt me to go there after exporting.
            _t.useCollections = false -- Don't create collections, don't use them, don't prompt... - I got this thing, don't help too much...
            _t.useCollections = nil -- Let plugin decide (@28/Oct/2013, it'll decide "yes".
            
        Note: Only applies when enabling the "Confirm Smart Previews" option in export dialog box.
--]]            
_t.useCollections = nil -- Let plugin decide (@28/Oct/2013, it'll decide "yes".



--[[
        Master copy name - only applies to pre-export snapshotting, when %V option is specified.
        
        Examples:
            _t.masterCopyName = "Master" -- the default.
            _t.masterCopyName = "master" -- for you lower-case afficianados.
            _t.masterCopyName = nil -- let plugin decide (@28/Oct/2013, it will decide "Master").
            
--]]
_t.masterCopyName = nil



--[[
        Rigorous keyword duplicate checking - only applies if using post-export keyword clearing.
        
        Examples:
            _t.keywordDupCheckRigorous = false -- minimal duplicate checking - favors shallow keyword (duplicates deeper in hierarchy may not be detected - depends..).
            _t.keywordDupCheckRigorous = true -- entire keyword hierarchy will be searched for duplicates - very time consuming if keyword hierarchy is large.
            _t.keywordDupCheckRigorous = nil -- let plugin decide (@30/Oct/2013 0:38, it will *not* be rigorous).
--]]
_t.keywordDupCheckRigorous = nil



--[[
        Keyword delimiter (separator). Only applies if using post-export keyword clearing.
        
        Examples:
            _t.keywordSep = nil -- let plugin decide (@30/Oct/2013, it will decide "comma").
            _t.keywordSep = "," -- I want comma, in case plugin changes it's mind ;-}.
            _t.keywordSep = " " -- spaces for me (I have no spaces in my keywords).
            _t.keywordSep = "|" -- I gotta be different...
--]]
_t.keywordSep = nil



--[[
        Amount to add to dimensions to correct shortness bug in Lr5.0-Lr5.2 (5.3...?).
        
        Note: .1 is sometimes enough, but not usually, .5 is usually enough (but not always), and is sometimes too much.
        
        Original (compromise) value was .3, but that proved insufficient in some cases too. So, you may need to adjust this
        for problem files and use a different (plugin manager / preset manager) preset when exporting them.
--]]
_t.dimFixOffset = .4



--[[
        Filesystem time tolerance, used in conjunction with save-metadata validation.
        
        Smaller numbers assure no false positives, but may result in occasional or persistent inability to validate metadata saving.
        Larger numbers are less likely to have save-metadata validation timeouts, but run the risk of metadata being considered saved, when it wasn't yet.
        
        Most local file-systems are reporting times to Lr to the nearest second, +/- 1 second, so a file-system
        time tolerance of 2 is minimal. You may however need to bump this to 3 or 4, but local filesystem should not require more.
        Network filesystems may require up to several seconds. More than a dozen seconds or so would make me uneasy (may cause unreliable results).
        
        Examples:
            _t.fsTimeTolerance = 2 -- set to minimal (which @13/Nov/2013, is also the default).
            _t.fsTimeTolerance = 4 -- doubled to increase reliability of save-metadata validation.
            _t.fsTimeTolerance = 8 -- doubled to accomodate network file-system.
            _t.fsTimeTolerance = nil -- let plugin decide (@13/Nov/2013, it will decide: 2).
--]]
_t.fsTimeTolerance = nil



--[[
        Collection name separator - applies to 'Post-export Metadata -> Collect' only.
        
        Examples:
            _t.collNameSep = "," -- comma, the default.
            _t.collNameSep = " | " -- want commas in collection name..
            _t.collNameSep = nil -- let plugin decide (@17/Nov/2013 16:13, it'll decide "comma").
--]]
_t.collNameSep = nil



--[[
        Collection set - applies to 'Post-export Metadata -> Collect' only.
        
        Examples:
            _t.collSet = "My Collection Set" -- preferred collection set.
            _t.collNameSep = nil -- let plugin decide (@17/Nov/2013 16:13, it'll decide "rc Exportant").
--]]
_t.collSet = nil



--[[
        Determines whether to enable the deletion of originals following export.
        
        Until 6/Apr/2013 17:27 this was always presented, but I think it may make some folks nervous, so now requires this to be true.
        
        Examples:
            _t.enableDeleteOriginalsAfterExport = false -- do not offer "Delete Originals after Export" feature in UI.
            _t.enableDeleteOriginalsAfterExport = true -- do offer "Delete Originals after Export" feature in UI (note: there are a few other hoops user will need to jump through...).
--]]
_t.enableDeleteOriginalsAfterExport = false



--[[
        Splat Delete - Enable/Disable.
        
        set true to enable, false to disable, for example:
        
        _t.splatDeleteOk = true -- plugin will attempt to use windows keyboard sequence Ctrl-Shift-Alt-Delete (known as splat delete) to delete selected photos.
        _t.splatDeleteOk = false -- plugin will prompt user to delete selected photos, and make no attempt to do it programmatically.
        
        Note: @30/Jan/2013 2:41, this feature should remain disabled in mac environment.
--]]
if WIN_ENV then
    _t.splatDeleteOk = false
elseif MAC_ENV then
    _t.splatDeleteOk = false
end



-- return config table
return _t